# The Last Ninja Game
![Game](./img/img_001.png)

Короче. Это попытка разобраться с игровыми механиками, такими как:
- Коллизии
- Анимация персонажей
- Построение уровней
- Камера, которая следит за игроком
- Параллаксом
- ИИ врагов
- и т.д.

## What's new
- Добавился [2ой уровень](https://bakudas.itch.io/generic-dungeon-pack) `./assets/level02` и для того чтобы на него перейти, <br/>
нужно собрать все монетки и встать в позицию под зеленой стрелкой (в конце карты)<br/>
![Green Arrow](./img/img_003.png)
- Можно загружать уровни через `query` запрос, например http://localhost:8080/?level=02 - загрузит 2ой уровень
- Добавил [тайлы](https://luizmelo.itch.io/monsters-creatures-fantasy) для 4х противников<br/>
![Enemies](./img/img_002.png)
- Добавил базовый набор движений + возможность задавать противников на карте уровня

### Enemies
- Skeleton
- Flying Eye
- Goblin
- Mushroom

Здесь `./assets/enemies`, лежат тайлы.
Здесь `./assets/animation-maps`, лежат мапы анимации:
- `attack` - атака
- `idle` - ожидание
- `move` - движение
- `dead` - смерть персонажа
- `block` - блок (только для `skeleton`)
- `take-hit` - урон

Их характеристик выделены в отдельный объект `EnemyType`, файла `./src/world/constants.js`.
И добавлена функция `createEnemy` в класс `./src/world/objects/objects-factory.js`.

### Tiled Map Editor
#### Уровни
Немного, как организовано хранение уровня и всех его свойства.

- `level 01` - `./assets/level01/level01.json`
- `level 02` - `./assets/level02/level02.json`

Оказалось, что все параметры уровня удобно моделировать и хранить в `tmx` формате, с дальнейшей выгрузкой в `JSON` формат:
- карта уровня
- слои карты уровня (например, когда мы хотим поместить объекты, которые будут перед игроком)<br/>
![Map Layer](./img/img_004.png)
- противники
- размер экрана
- размер `camera trap`
- позиция игрока
- позиции монеток (объектов)
- точка перехода на следующий уровень
- расположение коллизий

##### Описание слоев
- `before-layer` - слой, который будет наложен поверх всех
- `collisions` - слой, где располагаются координаты коллизий и их тип
- `respawn` - слой, где указаны координаты точек респауна (пока как задумка, чтобы не возвращаться при выходе за пределы карты на начальную точку)
- `level` - слой, где задаются некоторые свойства, такие как:
1. `screen` - размер экрана (собственно размер канвы)
2. `camera-trap` - исходное положение камеры
3. `player` - координаты исходной точки игрока
4. `next-level-gate` - координаты "ворот" следующего уровня (когда будет коллизия с игроком, то грузим следующий уровень)
5. `next-level-arrow` - метка, где находится "ворота" следующего уровня (видима, только когда будут выполнены все условия, сейчас это - собрать все монетки)
6. `prev-level-gate` - координаты "ворот" предыдущего уровня (пока не реализовано и надо думать, есть ли смысл)
- `enemies` - слой, где располагаются координаты противников с их типами:
1. `skeleton`
2. `flyingEye`
3. `goblin`
4. `mushroom`
- `coins` - слой, где указываются координаты монеток (скорее всего, это будет задел на будущее, где можно будет помещать x,y объекта и его тип, т.к. помимо монеток могут быть другие объекты)

##### Описание дополнительных свойств
- `tilewidth` - базовая ширина спрайта в пикселях
- `tileheight` - базовая высота спрайта в пикселях
- `width` - ширина всего уровня в кол-ве спрайтов
- `height` - высота уровня в кол-ве спрайтов

#### Анимация персонажей
Таким же образом удобно хранить анимацию персонажей, где слой, его имя, означает то или иное действие.
А с учетом, что высота карты это один спрайт (берется из тайла персонажа), то на выходе получаем JSON
со слоями и массивом индексов из набора.

- `player` (основные движения) - `./assets/animation-maps/ninja.json`
- `player` (бег с мечом) - `./assets/animation-maps/ninja-sword.json`
- `player` (атака из лука) - `./assets/animation-maps/ninja-bow.json`
- `flying eye` - `./assets/animation-maps/flying-eye.json`
- `goblin` - `./assets/animation-maps/goblin.json`
- `mushroom` - `./assets/animation-maps/mushroom.json`
- `skeleton` - `./assets/animation-maps/skeleton.json`

Например, для игрока определены следующие слои:
- `idle` - ожидание
- `crouch` - приседание
- `slide` - скольжение
- `flip` - переворот в верхней точке прыжка
- `move` - движение
- `jump` - прыжок
- и т.д.

## Tips&Tricks
Здесь описаны "механики", с которыми удалось как-то разобраться.
- [Статья](https://www.gamasutra.com/blogs/YoannPignole/20131010/202080/The_hobbyist_coder_1_2D_platformer_controller.php?print=1),
где можно почитать реализацию коллизий через `ray`, думаю, надо переходить на неё, т.к. текущая реализация удобна, когда
это ограниченное пространство (нет лагов, когда ускорение по Y добавляет следующе движение за индекс) и все объекты
строго одного размера.

### Как работают коллизии
Определено 15 типов взаимодействий объекта с элементами уровня.
Все они исходят из того, что представляя каждую сторону в виде бита, мы получаем
возможность оформить свой уникальный код, переведя его из `binary` в `decimal` систему.

Вся логика, определяющая куда "выталкивать" объект в зависимости от типа, определена в
классе `src/world/collider.js`, а сам вызов в функции `collideObject` класса `src/world/collide-object.js`.

#### Каждая сторона платформы определяется своим битом

    0 0 0 0 = l b r t (left bottom right top)

    0000 = 0  tile 0:    0    tile 1:   1     tile 2:    0    tile 15:    1
    0001 = 1           0   0          0   0            0   1            1   1
    0010 = 2             0              0                0                1
    1111 = 15        No walls     Wall on top      Wall on Right      four walls

#### Сейчас поддерживается 15 типов побитовых масок

    0000 00 - no walls               ничего не делаем
    0001 01 - top wall               можно встать на платформу сверху
    0010 02 - right wall             упираемся при движении | <-
    0011 03 - right-top wall         
    0100 04 - bottom wall            упираемся при прыжке в нижную часть платформы
    0101 05 - bottom-top wall        
    0110 06 - bottom-right wall      
    0111 07 - bottom-right-top wall
    1000 08 - left wall              упираемся при движении -> |
    1001 09 - left-top wall
    1010 10 - left-right wall
    1011 11 - left-right-top wall
    1100 12 - left-bottom wall
    1101 13 - left-bottom-top wall
    1110 14 - left-bottom-right wall
    1111 15 - all walls

#### Расположение маски на уровне

Сейчас работает следующий принцип задания масок коллизий на уровне.

- Определяем размер базового спрайта, например 16x16
- Говорим, что экран будет размером 64x32 (размеры должны быть кратны спрайту)
- Представляем размер в виде массива - 4 столбца * 2 строки, где `0`, условно,
  пустое место, а `1` там где будет рисоваться платформа (например, изображение блока из кирпича)
```javascript
const map = [0, 0, 0, 0,
             1, 1, 1, 1]
```

Теперь, определяем нужную маску там, где это необходимо.
Например, мы хотим, чтобы игрок "ходил" по блокам из кирпича -- это может быть маска `15` (все стороны) 
```javascript
const collisionMap = [0 , 0 , 0 , 0 ,
                      15, 15, 15, 15]
```

Теперь, когда объект передвигается по уровню, зная размер хитбокса, базовый размер спрайта,
размер экрана и т.д., мы можем вычислить его положение в нашей сетке, т.е. индекс массива.

Далее, зная маску коллизии, координаты объекта и платформы, вычисляем, куда можно, а куда нельзя 
двигаться и "выталкиваем" объект в противоположную сторону от той или иной стороны платформы.

Можно представить это в следующем виде:
- 0 - пустое пространство
- 1 - платформа, через которую нельзя пройти сверху
- x - игрок, на которого действует гравитация и каждый кадр к ускорению по Y координате + 2 (условно).
таким образом наш объект "падает"
```
    1й шаг         2й шаг         3 шаг          4 шаг          5 шаг          6 шаг

    0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0
    0 0 x 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0  0 0 0 0 0 0 0
    0 0 0 0 0 0 0  0 0 x 0 0 0 0  0 0 0 0 0 0 0  0 0 x 0 0 0 0  0 0 0 0 0 0 0  0 0 x 0 0 0 0
    1 1 1 1 1 1 1  1 1 1 1 1 1 1  1 1 x 1 1 1 1  1 1 1 1 1 1 1  1 1 x 1 1 1 1  1 1 1 1 1 1 1
```
  
Т.е. как только объект пересекается своими координатами с точкой, где располагается коллизия,
запускаем проверку. В нашем случае это маска `1`, которая говорит, что мы должны "выталкивать"
объект вверх (визуально, это будет "встать на платформу").

В `1, 2 и 3 шаге`, объект падает с учетом гравитации, а коллизия, вычисляя, что:
```javascript
const { y, oldY, height } = object
if (y + height > platform.y && oldY + height <= platform.y) {
  // Текущая координата объекта вылезла ниже платфомы, а старая координата на уровне или выше
  object.y = platform.y - 0.01 - height // выталкиваем объект, чтобы он оказался над платформой
  object.velocityY = 0 // зануляем ускорение по Y координате
}
```

В `4 шаге` наш объект оказывается над платформой.

Далее, на `5 шаге` снова действует гравитация, падение вниз, коллизия и "выталкивание" на `6 шаг`.

Все остальные типы работают по принципу описанному выше.

### Как работает анимация персонажа и их связь к тому или иному действию (например, атака)
Сейчас организовано следующим образом:
- Класс `src/controller.js` слушает ввод с клавиатуры и перенаправляет на персонажа
- Класс `src/world/interpreters/ninja-interpreter.js` интерпретирует состояние персонажа в действие
- Класс `src/world/animation/ninja-animation/index.js` по флагам, который возвращает интерпретатор,
подставляет ту или иную анимацию и запускает выполнения действия, когда она полностью выполняется

Анимация - это последовательная подстановка следующего кадра, в зависимости какая задержка была выставлена.
Здесь `src/graphic/animator.js` находится реализация, которая от типа анимации `pause` или `loop`, каждый заданный
кадр вычисляем следующий слайд и вызываем колбэк, когда она закончилась.

Сама графика хранится в виде `tileset` - это `.png` где на сетке расположена раскадровка того или иного объекта.
Например, в файле `src/assets/ninja-bow-tiles.png` представлена раскадровка атаки из лука (на земле и в воздухе).

Загружая ресурс через класс `src/graphic/sprite-sheet.js`, куда передаем размеры картинки, размеры спрайта,
мы получаем массив кадров по их индексу.
Например, так мы получим кадры для анимации стрельбы из лука на земле:
```javascript
const BOW_TILES = {
  name: 'ninja-bow-tiles', // уникальное имя ресурса, которое грузится классом src/loaders/image-loader.js
  width: 200, // ширина картинки
  height: 148, // высота картинки
  spriteWidth: 50, // ширина спрайта (кадра)
  spriteHeight: 37 // высота спрайта (кадра)
}
// Получаем объект, где хранится массив кадров с их координатами на тайле.
const bowAttackFrames = new SpriteSheet(BOW_TILES).getAnimationFrames(1, 2, 3, 4, 5, 6, 7, 8, 9)
// Далее, помещаем его в объект анимации, где у нас, в зависимости от типа, вычисляется следующий кадр
const bowAttackAnimation = new Animator(bowAttackFrames, 3, AnimatorMode.pause)
// Обновляем следуюий кадр анимации
bowAttackAnimation.animate((done, key) => {
  // колбэк, когда анимация закончилась или её прервали
  done && player.bowAttack() // условно
})

// Отрисовка текущего кадр
new Display().drawSprite(bowAttackAnimation.animation)
```

Координаты вычисляются в зависимости от индекса картинки.
Например, если мы указали индекс 3, то для размеров из примера это будет так:
```javascript
const index = 3
const x = (-- index * spriteWidth) % width
const y = Math.trunc((-- index * spriteWidth) / width) * spriteHeight
```

https://developer.mozilla.org/ru/docs/Web/API/CanvasRenderingContext2D/drawImage

Для отрисовки кадра, используется метод `canvas.drawImage`, где указываем тайл, где расположен
наш кадр, его координаты на нем и координаты, куда поместить "вырезанный кусок" на канву.

### Принцип работы общей камеры игры
Тут можно посмотреть какие типы камер бывают:
- https://www.youtube.com/watch?v=l9G6MNhfV7M
- https://www.youtube.com/watch?v=pdvCO97jOQk

Я выбрал тип `camera trap`, т.к. для платформеров она более оптимальна.
Реализация лежит здесь `src/main-camera.js`.

В 2х словах: задается размер экрана, общий размер уровня и позиция "рамки", выходя за границы оной, игрок
"двигает" камеру, т.е. задает `x` и `y` координаты.
И при выводе всех картинок, мы корректируем их позиции относительно неё.

## Bugs
- Если бежать до конца карты, и не отпуская стрелки вправо, уперевшись в край карты прыгнуть,
то почему-то отрабатывает коллизия, которая находится в самом начале и игрок "встает на платформу
в воздухе"

## TODO
- Разобраться как хранить анимацию и карту уровня со списком коллизий
      
  1. https://www.youtube.com/watch?v=r6F7WafrvTE&t - создание графики
  2. https://www.youtube.com/watch?v=PmZ38JHEAys&t - тайловая карта

- Разобраться как можно считать коллизии, если хит-бокс объекта больше базового размера спрайта
- Заливка фона "куском" картинки, например залить все небо из `./assets/level01/sky.png`
- Анимация и ИИ врагов (попытка здесь `src/world/npc/dummy-behavior`)
- Коллизии ударов, стрел и файеров с препятствиями и врагами
- Анимация при уроне персонажа
- Сбор предметов
- Ограничение по кол-ву стрел и маны
- Добавить возможность блока от ударов врагов 

## Links
1. https://m.habr.com/ru/company/pixonic/blog/428892/ - гайд по созданию игрового ИИ
2. https://rvros.itch.io/animated-pixel-hero - тайлы персонажа
3. https://thorbjorn.itch.io/tiled - приложение, где можно загружать тайловые карты и формировать JSON
4. https://ansimuz.itch.io/magic-cliffs-environment - уровень 01
5. https://edermunizz.itch.io/free-pixel-art-forest - уровень 02 (подуровень)
6. https://oco.itch.io/ - еще какие-то тайлы
7. https://www.spriters-resource.com/ - бесплатные спрайты
8. https://itch.io/game-assets/free - еще бесплатные тайлы
9. https://vectorjs.org/ - библиотека Vector
10. https://suvitruf.ru/2019/03/13/4305/a-brief-introduction-to-lerp/ - линейная интерполяция LERP
